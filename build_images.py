#!/usr/bin/python
#encoding:utf-8
#Filename: build_images.py

import os
import sys
import re
import time
from hashlib import md5

from xc_helper_base import XCProject
from xc_helper_base import StringResource
from xc_helper_base import StringObject
from xc_helper_base import message

class ImagesBuilder(object):
	""" Build macros for image resources """
	def __init__(self, xcodeproj):
		super(ImagesBuilder, self).__init__()
		self.xcodeproj = xcodeproj

	def buildImagesMacros(self):
		images = {}
		duplicated = {}
		for f in self.xcodeproj.getfiles():
			fileType = str(self.xcodeproj.objectWithKeyPath(['lastKnownFileType'], f))
			if fileType and fileType[0:6] == 'image.':
				name = self.imageNameFromPath(os.path.basename(f['path']))
				keyName = name.lower()
				if images.has_key(keyName) and os.path.basename(images[keyName]['path']).lower() == os.path.basename(f['path']).lower():
					if duplicated.has_key(keyName):
						duplicated[keyName].append(f['full_path'])
					else:
						duplicated[keyName] = [f['full_path'], images[keyName]['path']]
				else:
					images[keyName] = {'name': name, 'path':f['full_path']}
		if len(duplicated) > 0:
			errmsg = 'Duplicated image names found:'
			for name in duplicated.keys():
				errmsg = errmsg + '\n' + '\n'.join(['%s' % t for t in duplicated[name]]) + '\n'
			message().error(errmsg)
			sys.exit(1)

		if len(images) == 0:
			message().info('Done!')
			return

		images = dict((k, v['name']) for k, v in images.items())

		autoGenDir = os.path.join(self.xcodeproj.projectHome, 'autoGen')
		if not os.path.isdir(autoGenDir):
			os.makedirs(autoGenDir)

		if not os.path.isdir(autoGenDir):
			message().error('Failed to create directory: "%s"' % autoGenDir)
			sys.exit(1)

		macroFile = self.xcodeproj.projectClassPrefix() + 'ImageResources.h'
		macroFile = os.path.join(autoGenDir, macroFile)
		
		currentVersion = self.currentImageResourceHash(images.keys())
		fileVersion = self.macrosFileVersion(macroFile)
		if fileVersion and currentVersion and currentVersion.lower() == fileVersion.lower():
			message().info('Resources has no changes, Done!')
			return

		fp = open(macroFile, 'wb')
		if not fp:
			message().error('Failed to open file: %s' % macroFile)
			sys.exit(1)

		try:
			# output file header
			fp.write('///\n/// %s\n' % os.path.basename(macroFile))
			fp.write('/// %s\n///\n' % self.xcodeproj.productName())
			fp.write('/// This file is autogenerated via scripts\n///\n')
			now = long(time.time())
			timeArray = time.localtime(now)
			fp.write('/// Modified by xc_helper_script at %s\n' % time.strftime("%Y-%m-%d", timeArray))
			fp.write('/// Copyright (c) 2012-%s %s. All rights reserved.\n///\n' % (time.strftime("%Y", timeArray), self.xcodeproj.objectWithKeyPath(['objects', self.xcodeproj.rootObjectID, 'attributes', 'ORGANIZATIONNAME'])))
			fp.write('/// VERSION:%s\n' % str(currentVersion))
			fp.write('///\n\n')

			# output images macros
			for imageName, path in images.items():
				macroName = re.sub(r'[^0-9a-zA-Z_]', '_', imageName)
				macroName = '%sIMG_%s' % (self.xcodeproj.projectClassPrefix(), macroName.upper())
				fp.write('#define %s  @"%s"\n' % (macroName, path))

		except Exception, e:
			message().error('Exception while writing file:%s, error:%s' % (os.path.basename(macroFile), e))
			sys.exit(1)

		finally:
			fp.close()

		message().info('Done!')

		

	def currentImageResourceHash(self, images):
		if not images:
			return None
		content = '\n'.join(['%s' % (item) for item in sorted(images)])
		m = md5()
		m.update(content)
		return m.hexdigest()


	def macrosFileVersion(self, macrosFile):
		if not os.path.isfile(macrosFile):
			return None

		fp = open(macrosFile, 'rb')
		if not fp:
			message().warning('Can not open file: %s' % macrosFile)
			return None

		version = None
		while True:
			lines = fp.readlines(100)
			if not lines:
				break
			for l in lines:
				matches = re.search(ur"^///\s*VERSION:\s*([0-9a-zA-Z]{32})", l)
				if matches:
					version = matches.group(1)
					break
		fp.close()
		return version

	def imageNameFromPath(self, path):
		name = ''
		for component in path.split('.'):
			if len(name.strip()) == 0:
				name = component
				pos = name.find('@')

				if pos >= 0:
					name = name[0: pos]

				pos = name.find('~')
				if pos >= 0:
					name = name[0: pos]

		return name



		